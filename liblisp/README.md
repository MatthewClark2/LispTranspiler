# Lisp Standard Library and Runtime

This library is designed to be used as a runtime for C code generated by the lispc Rust package. The supported LISP
dialect is roughly related to Scheme chiefly in its utilization of lambda calculus and relatively simple type structure.
As this is still a primarily infant project, the specific details pertaining to functionality and specification are
subject to change at any time. This document serves to try and keep up with such changes and provide a rough overview of
how the runtime works. Please check the README associated with the Rust project for semantic details.

When reading the code itself, you may notice some comments labelled `NOTE`. These are there to explain certain quirks
that may appear when attempting to use the library, as well as the reasoning behind leaving those quirks.

## Special Forms

### if

Takes the form `(if *condition* *true-branch* *false-branch*)`. Returns the value of the appropriate branch without 
executing the other. For example, the following program

```scheme
(if #t
    (valued-function)
    (exit))
    
(format "program exited normally")
```

will print the string without prematurely exiting the program.

### define

Takes the form `(define *symbol* *value*)`, where the value can be any valued form, including not only literals, but
also conditions, lambdas, and function calls. This value is defined at the top level, and is available in all subsequent
code. It is not valued in and of itself. As such, the following program will compile

```scheme
(define x 10)
(define y x)

(format (* x y))
```

The following will not.

```scheme
(define y (define x 10))
```

### lambda

Takes the form `(lambda *arg-list* *body*)`, where arg-list is a list of symbols and the body is a single valued form. 

Variadic function arguments are supported via the `.` symbol. For example, `(lambda (n . nums) (* n (apply + nums)))`
creates a function that takes at least one number, multiplying that by the sum of any other numbers provided.

### defun

Takes the form `(defun *name* *arg-list* *body*)`. Similar to `(define *name* (lambda *arg-list* *body*))`, but allows
for the name to be used as a function directly. See the difference.

```scheme
(defun add (x y) (+ x y))
    
(define add2 (lambda (x y) (+ x y)))

(add 1 2)
(invoke add2 (1 2))
; (add2 1 2)  ;; uncomment this line to see that it does not compile.
```

## Data Types

### Numbers

Integers are the least precise type. Rational numbers are a super set of integers stored in their simplest form. Real 
numbers are a super set of rationals, and represent standard 64 bit floating point numbers. Complex numbers a superset
of real numbers stored using two floating point real numbers.

### Booleans

Primitive true and false constants. There's no requirement for implementation other than the fact that they are distinct
from other data types. "Truthyness" is a factor in this language, however only `nil` and `false` are considered to be 
not true.

### Nil

`nil` is the LISP equivalent of NULL. `nil` is equivalent only to itself regardless of strictness. In use as a value, it
is equivalent to an empty list. The consequence of this is that `(eqv? nil (list))` and `(eqv? nil '())` are both true.

### Symbols
Symbols are to be interned upon creation. This may eliminate the need for keywords, but we'll have to see when we get 
there.

### Strings

Strings are stored in a PASCAL format, containing a character buffer and the length of the string. The null termination
of a LISP string is not defined and should not be relied upon. When dealing with normal C string functions, be sure to
use the associated length. Only ASCII characters are officially supported due to the need to generate C code.

### Lists

Lists are stored in memory as linked lists where the final element points to `NULL`, a sentinel value chosen due to not
being a valid LISP value. Empty lists are thus saved as `{.car = NULL, .cdr = NULL}`.

Improper lists (i.e. Scheme pairs) may be used with standard list functions as well.

The destruction of a list follows from the start of the list along to the final element. As a result, the deletion of a
circular list is not well defined.

### Lambdas

Lambdas are the mechanism by which functions can be generated on the fly. Each lambda declaration creates a C function
with a standard function signature at compile time. At runtime, lambda declarations return a
Lambda object, which contains a pointer to the generated function and a vector of captured parameter values. The 
generated C function will extract those values as necessary. See [here](#calling-lambdas) for more information.

Lambdas should only be applied through the `invoke` C function.

## Function Conventions

### Calling Functions

All LISP functions have the same `LispDatum*(LispDatum**, size_t)` function signature. They take an array of LispDatum 
pointers and the size of that array, perform some operation according to the body of the function, and return the result
of that operation as a LispDatum.

### Calling Lambdas

Functions generated from lambda expressions always take a lambda object as their first argument. For example:

```scheme
(lambda (x) (f a x))
```

defines a lambda that captures some value `a`, and will generate a function something like:

```c++
LispDatum* generated_name(LispDatum** args, size_t nargs) {
  auto lambda = args[0];
  auto a = lambda->captures[0];
  auto x = args[1];
  return f([a, x], 2)
}
```

### Error Handling

In order to avoid raising and handling traps, all lisp functions should return a pointer to a lisp value. If the
function call results in an error, the NULL pointer is returned. Functions that do not return any value should return
the NIL static constant. Since the library is built under the assumption that NULL pointers are never provided,
attempts to access them will simply crash. This behavior is not ideal, but it will be dealt with in time once enough 
debugging information can be added into the program. It may be worthwhile to have a debugging intermediate function that
checks for NULL returns and gracefully terminates the program, while more optimized compilations skip this step and hard
crash on failure. 

## Other Minutiae

I need some kind of name other than just "LISP". Considering that the compiler is going to be written in Rust, I'm
thinking about a name like Steam, mostly so I can call the runtime the Steam Engine.